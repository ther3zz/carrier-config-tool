// --- START OF FILE static/js/script.js ---
// --- Global Variables ---
let vonageStoredIps = [];
let vonageIncludeStoredIps = true;
let vonageStoredUris = [];
let successfullyPurchasedNumbers = [];
let appliedConfiguration = {};
let failedNpaPurchases = []; 
let isOperationCancelled = false; 
let npaData = {}; 
let vonagePsipDomains = []; 
let vonageSubaccounts = []; 

// --- Credential & Session Variables ---
let masterKey = null;
let storedCredentials = [];

// --- Centralized Settings ---
let appSettings = {
    max_concurrent_requests: 5,
    delay_between_batches_ms: 1000,
    store_logs_enabled: false,
    treat_420_as_success_buy: false,
    verify_on_420_buy: false,
    treat_420_as_success_configure: false
};


// --- Country Code Data ---
const countryData = [
    { name: "United States", code: "US", dial: "1" }, { name: "United Kingdom", code: "GB", dial: "44" },
    { name: "Canada", code: "CA", dial: "1" }, { name: "Afghanistan", code: "AF", dial: "93" },
    { name: "Albania", code: "AL", dial: "355" }, { name: "Algeria", code: "DZ", dial: "213" },
    { name: "American Samoa", code: "AS", dial: "1684" }, { name: "Andorra", code: "AD", dial: "376" },
    { name: "Angola", code: "AO", dial: "244" }, { name: "Argentina", code: "AR", dial: "54" },
    { name: "Australia", code: "AU", dial: "61" }, { name: "Austria", code: "AT", dial: "43" },
    { name: "Bahamas", code: "BS", dial: "1242" }, { name: "Bahrain", code: "BH", dial: "973" },
    { name: "Bangladesh", code: "BD", dial: "880" }, { name: "Belgium", code: "BE", dial: "32" },
    { name: "Brazil", code: "BR", dial: "55" }, { name: "China", code: "CN", dial: "86" },
    { name: "Colombia", code: "CO", dial: "57" }, { name: "Egypt", code: "EG", dial: "20" },
    { name: "France", code: "FR", dial: "33" }, { name: "Germany", code: "DE", dial: "49" },
    { name: "India", code: "IN", dial: "91" }, { name: "Indonesia", code: "ID", dial: "62" },
    { name: "Ireland", code: "IE", dial: "353" }, { name: "Israel", code: "IL", dial: "972" },
    { name: "Italy", code: "IT", dial: "39" }, { name: "Japan", code: "JP", dial: "81" },
    { name: "Mexico", code: "MX", dial: "52" }, { name: "Netherlands", code: "NL", dial: "31" },
    { name: "New Zealand", code: "NZ", dial: "64" }, { name: "Nigeria", code: "NG", dial: "234" },
    { name: "Norway", code: "NO", dial: "47" }, { name: "Pakistan", code: "PK", dial: "92" },
    { name: "Philippines", code: "PH", dial: "63" }, { name: "Poland", code: "PL", dial: "48" },
    { name: "Portugal", code: "PT", dial: "351" }, { name: "Russia", code: "RU", dial: "7" },
    { name: "Saudi Arabia", code: "SA", dial: "966" }, { name: "South Africa", code: "ZA", dial: "27" },
    { name: "South Korea", code: "KR", dial: "82" }, { name: "Spain", code: "ES", dial: "34" },
    { name: "Sweden", code: "SE", dial: "46" }, { name: "Switzerland", code: "CH", dial: "41" },
    { name: "Turkey", code: "TR", dial: "90" }, { name: "United Arab Emirates", code: "AE", dial: "971" }
];
const countryDialingCodes = countryData.reduce((acc, country) => { acc[country.code] = country.dial; return acc; }, {});


// --- Fetch Wrapper ---
async function apiFetch(url, options = {}) {
    const headers = new Headers(options.headers || {});
    if (appSettings.store_logs_enabled) { headers.set('X-Log-Request', 'true'); }
    // Do not set Content-Type for FormData, the browser does it with the correct boundary.
    if (options.body && !(options.body instanceof FormData) && !headers.has('Content-Type')) { 
        headers.set('Content-Type', 'application/json');
    }
    options.headers = headers;
    return fetch(url, options);
}

// --- Helper functions ---
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
function stopAllOperations() { isOperationCancelled = true; console.log("Stop requested. isOperationCancelled set to true."); document.querySelectorAll('.stop-button').forEach(btn => { if (btn.style.display !== 'none') { btn.disabled = true; btn.textContent = 'Stopping...'; } }); displayResponse("Stop requested. The current batch of requests will finish, then the process will halt.", 'pending'); }
function toggleOperationControls(operationName, isStarting) { const controls = { individual: { startBtn: document.getElementById('vonage_purchase_button'), stopBtn: document.getElementById('stop_individual_purchase_button'), }, bulk: { startBtn: document.getElementById('vonage_bulk_npa_purchase_button'), stopBtn: document.getElementById('stop_bulk_purchase_button'), reattemptBtn: document.getElementById('vonage_reattempt_npa_button') }, configure: { startBtn: document.getElementById('vonage_configure_button'), stopBtn: document.getElementById('stop_configure_button'), }, modify: { startBtn: document.querySelector('#vonageModifyDidForm button[type="submit"]'), stopBtn: document.getElementById('stop_modify_button'), }, release: { startBtn: document.querySelector('#vonageReleaseDidForm button[type="submit"]'), stopBtn: document.getElementById('stop_release_button'), } }; const op = controls[operationName]; if (!op) return; if (isStarting) { isOperationCancelled = false; if (op.startBtn) op.startBtn.style.display = 'none'; if (op.stopBtn) { op.stopBtn.style.display = 'inline-block'; op.stopBtn.disabled = false; op.stopBtn.textContent = (operationName === 'configure') ? 'Stop Configuration' : (operationName === 'modify') ? 'Stop Update' : (operationName === 'release') ? 'Stop Release' : 'Stop Purchase'; } if (op.reattemptBtn) op.reattemptBtn.style.display = 'none'; } else { if (op.startBtn) op.startBtn.style.display = 'inline-block'; if (op.stopBtn) op.stopBtn.style.display = 'none'; if (op.reattemptBtn) { if (failedNpaPurchases.length > 0) { const totalFailed = failedNpaPurchases.reduce((sum, item) => sum + item.quantity, 0); op.reattemptBtn.textContent = `Re-attempt ${totalFailed} Failed Purchase(s)`; op.reattemptBtn.style.display = 'inline-block'; op.reattemptBtn.disabled = false; } else { op.reattemptBtn.style.display = 'none'; } } } }
function formatMsisdnForApi(msisdn, country) { let msisdnForApi = String(msisdn).replace(/\D/g, ''); if (country.toUpperCase() === 'US' || country.toUpperCase() === 'CA') { if (msisdnForApi.length === 10) { msisdnForApi = '1' + msisdnForApi; } } return msisdnForApi; }
function getNationalNumber(msisdn, country) { let nationalNum = String(msisdn).replace(/\D/g, ''); const countryCodeUpper = country.toUpperCase(); const dialingCode = countryDialingCodes[countryCodeUpper]; if (dialingCode && nationalNum.startsWith(dialingCode)) { return nationalNum.substring(dialingCode.length); } if ((countryCodeUpper === 'US' || countryCodeUpper === 'CA') && nationalNum.length === 11 && nationalNum.startsWith('1')) { return nationalNum.substring(1); } return nationalNum; }
async function processInBatches(items, processFn, updateStatusFn, targetStatusListElement, getItemIdFn = null) { const maxConcurrent = appSettings.max_concurrent_requests; const delayBetween = appSettings.delay_between_batches_ms; const results = []; let itemIndex = 0; while (itemIndex < items.length) { if (isOperationCancelled) { console.log("Operation cancelled by user. Halting batch processing."); const remainingItems = items.slice(itemIndex); remainingItems.forEach((item, idx) => { let itemId = (getItemIdFn) ? getItemIdFn(item, itemIndex + idx) : item.msisdn || item.npa || item.id || `item-${itemIndex + idx}`; updateStatusFn(itemId, 'Cancelled by user.', 'error', targetStatusListElement); }); break; } const batch = items.slice(itemIndex, itemIndex + maxConcurrent); const batchPromises = batch.map((item, batchIdx) => { const overallIndex = itemIndex + batchIdx; let itemId = (getItemIdFn) ? getItemIdFn(item, overallIndex) : item.msisdn || item.npa || item.id || `item-${overallIndex}`; return processFn(item, overallIndex).then(value => ({ status: 'fulfilled', value, item, itemId })).catch(reason => ({ status: 'rejected', reason, item, itemId })); }); const batchResults = await Promise.all(batchPromises); results.push(...batchResults); batchResults.forEach(result => { if (result.status === 'fulfilled') { if (result.value && (result.value.status_code >= 200 && result.value.status_code < 300)) { let successMsg = result.value.message || (result.value.data ? JSON.stringify(result.value.data) : 'Success'); if (result.value.country) { successMsg += ` (Country: ${result.value.country})`; } updateStatusFn(result.itemId, successMsg, 'success', targetStatusListElement); } else { const errorMsg = result.value.error || (result.value.data ? JSON.stringify(result.value.data) : 'Failed (no error message)'); const statusCode = result.value.status_code || 'N/A'; updateStatusFn(result.itemId, `Failed: ${errorMsg} (Status: ${statusCode})`, 'error', targetStatusListElement); } } else { const errorMsg = result.reason.message || result.reason.error || 'Network/Parsing Error'; updateStatusFn(result.itemId, `Failed: ${errorMsg}`, 'error', targetStatusListElement); } }); itemIndex += batch.length; if (itemIndex < items.length && delayBetween > 0 && !isOperationCancelled) { console.log(`Waiting ${delayBetween}ms before next batch...`); const lastProcessedItemResult = results[results.length - 1]; const lastItemWasSuccess = lastProcessedItemResult && lastProcessedItemResult.status === 'fulfilled' && lastProcessedItemResult.value.status_code >= 200 && lastProcessedItemResult.value.status_code < 300; if (lastItemWasSuccess) { const lastProcessedItemId = lastProcessedItemResult.itemId; const statusElement = targetStatusListElement.querySelector(`li[data-status-id="${lastProcessedItemId}"] span:last-child`); if (statusElement) { const originalText = statusElement.textContent; updateStatusFn(lastProcessedItemId, `${originalText} (Delaying ${delayBetween / 1000}s...)`, 'pending', targetStatusListElement); await sleep(delayBetween); updateStatusFn(lastProcessedItemId, originalText, 'success', targetStatusListElement); } else { await sleep(delayBetween); } } else { await sleep(delayBetween); } } } return results; }

// --- Credential Management ---
async function handleSetMasterKey() { const keyInput = document.getElementById('masterKeyInput'); const statusDiv = document.getElementById('masterKeyStatus'); const managerUI = document.getElementById('credentialManagerUI'); const potentialKey = keyInput.value; if (!potentialKey) { statusDiv.textContent = 'Please enter a Master Key.'; statusDiv.className = 'status-error'; return; } statusDiv.textContent = 'Verifying key and loading credentials...'; statusDiv.className = 'status-pending'; try { const response = await apiFetch('/api/credentials/names'); if (!response.ok) throw new Error(`Server responded with status ${response.status}`); const data = await response.json(); masterKey = potentialKey; storedCredentials = data || []; keyInput.style.borderColor = '#4CAF50'; statusDiv.textContent = `Master Key set for session. ${storedCredentials.length} credential(s) loaded.`; statusDiv.className = 'status-success'; managerUI.style.display = 'block'; renderCredentialList(); populateAllCredentialSelectors(); } catch (error) { console.error("Failed to set master key or load credentials:", error); masterKey = null; storedCredentials = []; keyInput.style.borderColor = '#f44336'; statusDiv.textContent = `Error: Could not load credentials. Check console for details.`; statusDiv.className = 'status-error'; managerUI.style.display = 'none'; renderCredentialList(); populateAllCredentialSelectors(); } }
function renderCredentialList() { const container = document.getElementById('credentialListContainer'); const template = document.getElementById('credential-item-template'); if (!container || !template) return; container.innerHTML = storedCredentials.length === 0 ? '<p>No credentials saved yet.</p>' : ''; storedCredentials.forEach(cred => { const clone = template.content.cloneNode(true); clone.querySelector('.original-credential-name').value = cred.name; clone.querySelector('.credential-name-display').textContent = cred.name; clone.querySelector('.credential-key-hint').textContent = `(${cred.api_key_hint})`; const form = clone.querySelector('.credential-edit-form'); form.querySelector('.edit-credential-name').value = cred.name; form.querySelector('.edit-credential-api-key').value = cred.api_key; form.querySelector('.edit-credential-callback-type').value = cred.default_voice_callback_type || ''; form.querySelector('.edit-credential-callback-value').value = cred.default_voice_callback_value || ''; container.appendChild(clone); }); }
async function handleAddCredential(event) { event.preventDefault(); if (!masterKey) { displayResponse("Error: Master Key is not set.", "error"); return; } const name = document.getElementById('credentialName').value; const apiKey = document.getElementById('credentialApiKey').value; const apiSecret = document.getElementById('credentialApiSecret').value; const voice_callback_type = document.getElementById('credentialVoiceCallbackType').value; const voice_callback_value = document.getElementById('credentialVoiceCallbackValue').value; if (!name || !apiKey || !apiSecret) { alert("Friendly Name, API Key, and API Secret are required for new credentials."); return; } const payload = { name, api_key: apiKey, api_secret: apiSecret, master_key: masterKey, voice_callback_type, voice_callback_value }; displayResponse(`Saving new credential '${name}'...`, 'pending'); try { const response = await apiFetch('/api/credentials/save', { method: 'POST', body: JSON.stringify(payload) }); const data = await response.json(); if (!response.ok) throw new Error(data.error || 'Failed to save credential'); displayResponse(data.message, 'success'); document.getElementById('addCredentialForm').reset(); await handleSetMasterKey(); } catch (error) { handleFetchError(error, `Save Credential`); } }
function handleCredentialListActions(event) { const target = event.target; const form = target.closest('.credential-edit-form'); if (!form) return; event.preventDefault(); const originalName = form.querySelector('.original-credential-name').value; const originalCredData = storedCredentials.find(c => c.name === originalName); if (target.classList.contains('save-credential-changes-btn')) { handleSaveCredentialChanges(form, originalCredData); } else if (target.classList.contains('delete-credential-btn')) { handleDeleteCredential(originalName); } else if (target.classList.contains('cancel-credential-edit-btn')) { form.querySelector('.edit-credential-name').value = originalCredData.name; form.querySelector('.edit-credential-api-key').value = originalCredData.api_key; form.querySelector('.edit-credential-api-secret').value = ''; form.querySelector('.edit-credential-callback-type').value = originalCredData.default_voice_callback_type || ''; form.querySelector('.edit-credential-callback-value').value = originalCredData.default_voice_callback_value || ''; form.closest('details').open = false; } }
async function handleSaveCredentialChanges(form, originalCredData) { if (!masterKey) { displayResponse("Error: Master Key is not set.", "error"); return; } const newName = form.querySelector('.edit-credential-name').value; const newApiKey = form.querySelector('.edit-credential-api-key').value; const newApiSecret = form.querySelector('.edit-credential-api-secret').value; const newCallbackType = form.querySelector('.edit-credential-callback-type').value; const newCallbackValue = form.querySelector('.edit-credential-callback-value').value; if (!newName || !newApiKey) { alert("Friendly Name and API Key cannot be empty."); return; } const hasIdentifierChanged = newName !== originalCredData.name || newApiKey !== originalCredData.api_key; if (hasIdentifierChanged && !newApiSecret) { alert("A new API Secret is required when changing the Friendly Name or API Key."); return; } const payload = { original_name: originalCredData.name, name: newName, api_key: newApiKey, api_secret: newApiSecret, master_key: masterKey, voice_callback_type: newCallbackType, voice_callback_value: newCallbackValue }; displayResponse(`Updating credential '${originalCredData.name}'...`, 'pending'); try { const response = await apiFetch('/api/credentials/save', { method: 'POST', body: JSON.stringify(payload) }); const data = await response.json(); if (!response.ok) throw new Error(data.error || 'Failed to save changes'); displayResponse(data.message, 'success'); await handleSetMasterKey(); } catch (error) { handleFetchError(error, `Update Credential`); } }
async function handleDeleteCredential(credentialName) { if (!credentialName || !masterKey) return; if (confirm(`Are you sure you want to delete "${credentialName}"? This action cannot be undone.`)) { displayResponse(`Deleting '${credentialName}'...`, 'pending'); try { const response = await apiFetch('/api/credentials/delete', { method: 'POST', body: JSON.stringify({ name: credentialName }) }); const data = await response.json(); if (!response.ok) throw new Error(data.error || 'Failed to delete'); displayResponse(data.message, 'success'); await handleSetMasterKey(); } catch (error) { handleFetchError(error, `Delete Credential`); } } }
async function handleBulkImportCredentials() { if (!masterKey) { displayResponse("Error: Master Key must be set before importing.", "error"); return; } const textArea = document.getElementById('bulkCredentialInput'); const statusList = document.getElementById('importStatusList'); const statusArea = document.getElementById('importStatusArea'); const rawText = textArea.value; statusArea.querySelector('p').style.display = 'none'; statusList.innerHTML = ''; const lines = rawText.split('\n').filter(line => line.trim() !== ''); if (lines.length === 0) { displayResponse("Import field is empty. Please paste your data.", "error"); return; } const credentialsToImport = []; const invalidLines = []; lines.forEach((line, index) => { const parts = line.split('\t'); if (parts.length === 3 && parts[0].trim() && parts[1].trim() && parts[2].trim()) { credentialsToImport.push({ name: parts[0].trim(), apiKey: parts[1].trim(), apiSecret: parts[2].trim() }); } else { invalidLines.push(index + 1); } }); if (invalidLines.length > 0) { alert(`Warning: ${invalidLines.length} line(s) were skipped due to incorrect formatting (Line numbers: ${invalidLines.join(', ')}).`); } if (credentialsToImport.length === 0) { displayResponse("No valid credentials to import.", "error"); return; } let successCount = 0; for (const cred of credentialsToImport) { const li = document.createElement('li'); li.textContent = `Importing '${cred.name}'...`; statusList.appendChild(li); try { const response = await apiFetch('/api/credentials/save', { method: 'POST', body: JSON.stringify({ name: cred.name, api_key: cred.apiKey, api_secret: cred.apiSecret, master_key: masterKey }) }); const data = await response.json(); if (!response.ok) throw new Error(data.error); li.textContent = `SUCCESS: '${cred.name}' saved.`; li.className = 'status-success'; successCount++; } catch (error) { li.textContent = `FAILED: '${cred.name}' - ${error.message}`; li.className = 'status-error'; } } displayResponse(`Bulk import finished. ${successCount} of ${credentialsToImport.length} credentials saved successfully.`, successCount === credentialsToImport.length ? 'success' : 'error'); textArea.value = ''; await handleSetMasterKey(); }
async function handleImportFromFile() { const fileInput = document.getElementById('credentialFileUpload'); const statusList = document.getElementById('importStatusList'); const statusArea = document.getElementById('importStatusArea'); if (!masterKey) { displayResponse("Error: Master Key must be set before importing.", "error"); return; } const file = fileInput.files[0]; if (!file) { displayResponse("Error: Please select a credentials.json file to upload.", "error"); return; } statusArea.querySelector('p').style.display = 'none'; statusList.innerHTML = `<li>Uploading and processing '${file.name}'...</li>`; const formData = new FormData(); formData.append('credential_file', file); formData.append('master_key', masterKey); try { const response = await apiFetch('/api/credentials/import', { method: 'POST', body: formData }); const data = await response.json(); if (!response.ok) { throw new Error(data.error || 'An unknown error occurred during import.'); } statusList.innerHTML = ''; const { success, failed } = data.results; success.forEach(name => { const li = document.createElement('li'); li.textContent = `SUCCESS: Migrated '${name}' to database.`; li.className = 'status-success'; statusList.appendChild(li); }); failed.forEach(item => { const li = document.createElement('li'); li.textContent = `FAILED: '${item.name}' - ${item.reason}`; li.className = 'status-error'; statusList.appendChild(li); }); const finalMessage = `File import finished. Success: ${success.length}, Failed: ${failed.length}.`; displayResponse(finalMessage, failed.length > 0 ? 'error' : 'success'); if (success.length > 0) { await handleSetMasterKey(); } } catch (error) { handleFetchError(error, 'File Import'); statusList.innerHTML = `<li class="status-error">Error during import: ${error.message}</li>`; } finally { fileInput.value = ''; } }

// --- START: MODIFICATION (Revert rekey handler to simple JSON) ---
async function handleRekeyCredentials() {
    const oldKeyInput = document.getElementById('oldMasterKeyInput');
    const newKeyInput = document.getElementById('newMasterKeyInput');
    const statusList = document.getElementById('rekeyStatusList');

    const oldKey = oldKeyInput.value;
    const newKey = newKeyInput.value;

    statusList.innerHTML = ''; // Clear previous results

    if (!oldKey || !newKey) {
        alert("Both the Old and New Master Keys are required.");
        return;
    }
    if (oldKey === newKey) {
        alert("The new Master Key must be different from the old one.");
        return;
    }

    const confirmation = confirm(
        "--- CRITICAL WARNING ---\n\n" +
        "You are about to re-encrypt ALL stored credentials. If you provide the wrong 'Old Master Key', " +
        "ALL CREDENTIALS WILL BE PERMANENTLY CORRUPTED AND UNRECOVERABLE.\n\n" +
        "There is NO UNDO. Are you absolutely sure you want to proceed?"
    );

    if (!confirmation) {
        displayResponse("Re-keying operation cancelled by user.", "pending");
        return;
    }

    displayResponse("Attempting to re-key all credentials...", "pending");
    statusList.innerHTML = '<li>Processing... This may take a moment.</li>';

    const payload = {
        old_master_key: oldKey,
        new_master_key: newKey
    };

    try {
        const response = await apiFetch('/api/credentials/rekey', {
            method: 'POST',
            body: JSON.stringify(payload)
        });
        const data = await response.json();

        if (!response.ok) {
            throw new Error(data.error || 'An unknown error occurred during re-keying.');
        }

        statusList.innerHTML = ''; // Clear processing message
        const { success, failed } = data.results;

        success.forEach(name => {
            const li = document.createElement('li');
            li.textContent = `SUCCESS: '${name}' was re-keyed.`;
            li.className = 'status-success';
            statusList.appendChild(li);
        });
        
        failed.forEach(item => {
            const li = document.createElement('li');
            li.textContent = `FAILED: '${item.name}' - ${item.reason}`;
            li.className = 'status-error';
            statusList.appendChild(li);
        });

        const finalMessage = `Re-keying process finished. Success: ${success.length}, Failed: ${failed.length}.`;
        displayResponse(finalMessage, failed.length > 0 ? 'error' : 'success');
        
        if (failed.length === 0) {
            const instructionLi = document.createElement('li');
            instructionLi.innerHTML = `<strong>IMPORTANT:</strong> Your session key is now outdated. Please enter your <strong>new Master Key</strong> in the 'Session Master Key' field at the top and click 'Set & Load' to continue working.`;
            instructionLi.style.marginTop = '15px';
            instructionLi.style.fontWeight = 'bold';
            instructionLi.className = 'status-pending';
            statusList.appendChild(instructionLi);
            
            masterKey = null;
            document.getElementById('masterKeyInput').value = '';
            document.getElementById('masterKeyStatus').textContent = 'Credentials have been re-keyed. Please set the new Master Key.';
            document.getElementById('masterKeyStatus').className = 'status-pending';
            document.getElementById('credentialManagerUI').style.display = 'none';
        }
        
        oldKeyInput.value = '';
        newKeyInput.value = '';

    } catch (error) {
        const errorMessage = `Re-keying FAILED: ${error.message}`;
        displayResponse(errorMessage, 'error');
        statusList.innerHTML = `<li class="status-error">Operation failed. See main response area for details.</li>`;
    }
}
// --- END: MODIFICATION ---

// --- Vonage Functions ---
async function handleFetchSubaccounts(event) { event.preventDefault(); displayResponse('Fetching subaccounts...', 'pending'); const listContainer = document.getElementById('vonage-subaccount-list-container'); const listEl = document.getElementById('vonage-subaccount-list'); listEl.innerHTML = ''; try { const auth = getAuthPayload('vonage_manage_subaccounts'); const response = await apiFetch('/api/vonage/subaccounts', { method: 'POST', body: JSON.stringify(auth) }); const data = await response.json(); if (!response.ok) throw new Error(data.error || 'Failed to fetch subaccounts'); vonageSubaccounts = data.subaccounts || []; displayResponse(`Successfully fetched ${vonageSubaccounts.length} subaccounts.`, 'success'); renderSubaccounts(); listContainer.style.display = vonageSubaccounts.length > 0 ? 'block' : 'none'; } catch (error) { handleFetchError(error, 'Fetch Subaccounts'); } }
async function handleCreateSubaccount(event) { event.preventDefault(); displayResponse('Creating new subaccount...', 'pending'); try { const auth = getAuthPayload('vonage_create_subaccount'); const payload = { ...auth, name: document.getElementById('vonage_new_subaccount_name').value, secret: document.getElementById('vonage_new_subaccount_secret').value, use_primary_balance: document.getElementById('vonage_new_subaccount_use_primary_balance').checked }; const response = await apiFetch('/api/vonage/subaccounts/create', { method: 'POST', body: JSON.stringify(payload) }); const data = await response.json(); if (!response.ok) throw new Error(data.error || 'Failed to create subaccount'); handleBackendResponse(data); document.getElementById('vonageCreateSubaccountForm').reset(); } catch (error) { handleFetchError(error, 'Create Subaccount'); } }
function renderSubaccounts() { const container = document.getElementById('vonage-subaccount-list'); const template = document.getElementById('vonage-subaccount-template'); container.innerHTML = ''; if (!vonageSubaccounts || vonageSubaccounts.length === 0) { container.innerHTML = '<p>No subaccounts found.</p>'; return; } vonageSubaccounts.forEach(acc => { const clone = template.content.cloneNode(true); clone.querySelector('.subaccount-name-display').textContent = acc.name; clone.querySelector('.subaccount-key-display').textContent = `(${acc.api_key})`; const statusTag = clone.querySelector('.subaccount-status-tag'); statusTag.textContent = acc.suspended ? 'Suspended' : 'Active'; statusTag.className = acc.suspended ? 'subaccount-status-tag suspended' : 'subaccount-status-tag active'; const form = clone.querySelector('.vonage-subaccount-form'); form.querySelector('.subaccount-api-key').value = acc.api_key; form.querySelector('.api-key').value = acc.api_key; form.querySelector('.created-at').value = new Date(acc.created_at).toLocaleString(); form.querySelector('.balance').value = `${acc.balance} ${acc.account_currency}`; form.querySelector('.credit-limit').value = `${acc.credit_limit} ${acc.account_currency}`; form.querySelector('.subaccount-name').value = acc.name; form.querySelector('.suspended').checked = acc.suspended; form.querySelector('.suspended-status').textContent = acc.suspended ? 'Yes' : 'No'; form.querySelector('.use-primary-balance').checked = acc.use_primary_account_balance; form.querySelector('.use-primary-balance-status').textContent = acc.use_primary_account_balance ? 'Yes' : 'No'; container.appendChild(clone); }); }
async function handleSubaccountActions(event) { const target = event.target; if (target.classList.contains('save-subaccount-changes-btn')) { event.preventDefault(); const form = target.closest('.vonage-subaccount-form'); const apiKey = form.querySelector('.subaccount-api-key').value; const payload = { ...getAuthPayload('vonage_manage_subaccounts'), subaccount_key: apiKey, name: form.querySelector('.subaccount-name').value, suspended: form.querySelector('.suspended').checked }; displayResponse(`Updating subaccount ${apiKey}...`, 'pending'); try { const response = await apiFetch('/api/vonage/subaccounts/update', { method: 'POST', body: JSON.stringify(payload) }); const data = await response.json(); if (!response.ok) throw new Error(data.error || 'Failed to update'); handleBackendResponse(data); document.getElementById('vonageFetchSubaccountsForm').requestSubmit(); } catch (error) { handleFetchError(error, 'Update Subaccount'); } } else if (target.classList.contains('cancel-subaccount-edit-btn')) { event.preventDefault(); target.closest('details').open = false; } }
function generateVonagePsipPayload() { let acl = document.getElementById('vonage_psip_acl').value.split('\n').map(ip => ip.trim()).filter(ip => ip); if (vonageIncludeStoredIps) { const storedAcl = vonageStoredIps.map(item => item.ip); acl = [...new Set([...acl, ...storedAcl])]; } return { name: document.getElementById('vonage_psip_name').value, trunk_name: document.getElementById('vonage_psip_trunk_name').value, tls: document.getElementById('vonage_psip_tls').value, digest_auth: document.getElementById('vonage_psip_digest_auth').checked, srtp: document.getElementById('vonage_psip_srtp').value, acl: acl, domain_type: document.getElementById('vonage_psip_domain_type').value }; }
function generateVonagePsipCurlCommand() { try { const auth = getAuthPayload('vonage_psip'); const payload = generateVonagePsipPayload(); return `curl -X POST https://api.nexmo.com/v2/psip/domains \\ -H 'Content-Type: application/json' \\ -u '${auth.username}:${auth.password}' \\ -d '${JSON.stringify(payload, null, 2)}'`; } catch (error) { return `Error generating cURL: ${error.message}`; } }
async function handleVonagePsipSubmit(event) { event.preventDefault(); displayResponse('Sending PSIP domain creation request...', 'pending'); try { const auth = getAuthPayload('vonage_psip'); const payload = generateVonagePsipPayload(); const body = { ...auth, ...payload }; const response = await apiFetch('/api/vonage/psip/create', { method: 'POST', body: JSON.stringify(body) }); const data = await response.json(); handleBackendResponse(data); } catch (error) { handleFetchError(error, 'Create PSIP Domain'); } }
async function handleFetchPsipDomains(event) { event.preventDefault(); displayResponse('Fetching PSIP domains...', 'pending'); const listContainer = document.getElementById('vonage-psip-domain-list-container'); const listEl = document.getElementById('vonage-psip-domain-list'); listEl.innerHTML = ''; try { const auth = getAuthPayload('vonage_manage_psip'); const response = await apiFetch('/api/vonage/psip', { method: 'POST', body: JSON.stringify(auth) }); const data = await response.json(); if (!response.ok) throw new Error(data.error || 'Failed to fetch domains'); vonagePsipDomains = data.domains || []; displayResponse(`Successfully fetched ${vonagePsipDomains.length} domains.`, 'success'); listContainer.style.display = vonagePsipDomains.length > 0 ? 'block' : 'none'; } catch (error) { handleFetchError(error, 'Fetch PSIP Domains'); } }
async function handlePsipDomainActions(event) { /* Stub for future implementation */ }
async function handleVonageSearchSubmit(event) { event.preventDefault(); displayResponse('Searching for available numbers...', 'pending'); document.getElementById('search-results-area').style.display = 'none'; document.getElementById('purchase-controls').style.display = 'none'; try { const auth = getAuthPayload('vonage_search'); const payload = { ...auth, country: document.getElementById('vonage_search_country').value, type: document.getElementById('vonage_search_type').value, pattern: document.getElementById('vonage_search_pattern').value, search_pattern: document.getElementById('vonage_search_search_pattern').value, features: document.getElementById('vonage_search_features').value, }; const response = await apiFetch('/api/vonage/dids/search', { method: 'POST', body: JSON.stringify(payload) }); const data = await response.json(); if (!response.ok) throw new Error(data.error || 'Search failed'); renderSearchResults(data.numbers); } catch (error) { handleFetchError(error, 'DID Search'); } }
function renderSearchResults(numbers) { const resultsArea = document.getElementById('search-results-area'); const container = document.getElementById('search-results-container').querySelector('ul'); const countEl = document.getElementById('search-count'); const purchaseButton = document.getElementById('vonage_purchase_button'); container.innerHTML = ''; if (!numbers || numbers.length === 0) { countEl.textContent = '0'; container.innerHTML = '<li>No numbers found matching your criteria.</li>'; resultsArea.style.display = 'block'; purchaseButton.disabled = true; return; } countEl.textContent = numbers.length; numbers.forEach(num => { const li = document.createElement('li'); const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.className = 'did-checkbox'; checkbox.value = num.msisdn; checkbox.dataset.country = document.getElementById('vonage_search_country').value.toUpperCase(); const label = document.createElement('label'); label.appendChild(checkbox); label.append(` ${num.msisdn} - Features: ${num.features.join(', ')} - Cost: ${num.cost}`); li.appendChild(label); container.appendChild(li); }); resultsArea.style.display = 'block'; document.getElementById('purchase-controls').style.display = 'block'; updateSelectedCount(); }
function updateSelectedCount() { const selected = document.querySelectorAll('#search-results-container .did-checkbox:checked').length; document.getElementById('selected-count').textContent = selected; document.getElementById('vonage_purchase_button').disabled = selected === 0; }
async function handlePurchaseButtonClick() { /* Stub for individual purchase */ }
async function handleBulkNpaPurchaseClick() { /* Stub for bulk purchase */ }
async function handleConfigureClick() { /* Stub for configuration */ }
async function handleExportClick() { /* Stub for export */ }
async function handleVonageModifyDidSubmit(event) { event.preventDefault(); /* Stub for modify */ }
async function handleVonageReleaseDidSubmit(event) { event.preventDefault(); /* Stub for release */ }

// --- UI & DOM Functions ---
function populateCredentialSelector(container) { const triggerText = container.querySelector('.custom-select-trigger span'); const optionsContainer = container.querySelector('.custom-options'); const filterInput = container.querySelector('.credential-filter-input'); const valueInput = container.querySelector('.credential-selector-value'); if (!triggerText || !optionsContainer || !filterInput || !valueInput) return; optionsContainer.querySelectorAll('.custom-option:not(.filter-option)').forEach(opt => opt.remove()); filterInput.value = ''; const createOption = (text, value) => { const option = document.createElement('div'); option.classList.add('custom-option'); option.dataset.value = value; option.textContent = text; return option; }; let defaultText, defaultValue; if (!masterKey || storedCredentials.length === 0) { defaultText = masterKey ? '-- No Credentials Found --' : '-- Set Master Key First --'; defaultValue = ''; optionsContainer.appendChild(createOption(defaultText, '')); } else { defaultText = '-- Select a Credential --'; defaultValue = ''; optionsContainer.appendChild(createOption(defaultText, '')); storedCredentials.forEach(c => { optionsContainer.appendChild(createOption(`${c.name} (${c.api_key_hint})`, c.name)); }); } const manualOpt = createOption('== Manual Entry ==', 'manual'); manualOpt.style.fontWeight = 'bold'; optionsContainer.appendChild(manualOpt); triggerText.textContent = defaultText; valueInput.value = defaultValue; container.querySelector('.custom-option')?.classList.add('selected'); const filterOption = container.querySelector('.filter-option'); filterOption.style.display = storedCredentials.length > 5 ? 'block' : 'none'; }
function populateAllCredentialSelectors() { document.querySelectorAll('.credential-selector-container').forEach(populateCredentialSelector); }
function closeAllCustomSelects(exceptThisOne) { document.querySelectorAll('.custom-select-wrapper.open').forEach(wrapper => { if (wrapper !== exceptThisOne) { wrapper.classList.remove('open'); } }); }
function handleCustomSelectClick(event) { const wrapper = event.target.closest('.custom-select-wrapper'); if (!wrapper) { closeAllCustomSelects(); return; } const trigger = event.target.closest('.custom-select-trigger'); const option = event.target.closest('.custom-option:not(.filter-option)'); if (trigger) { const isOpen = wrapper.classList.contains('open'); closeAllCustomSelects(); if (!isOpen) { wrapper.classList.add('open'); const filterInput = wrapper.querySelector('.credential-filter-input'); if(filterInput && getComputedStyle(filterInput.parentElement).display !== 'none') { filterInput.focus(); } } } else if (option) { const container = wrapper.closest('.credential-selector-container'); const triggerText = wrapper.querySelector('.custom-select-trigger span'); const valueInput = container.querySelector('.credential-selector-value'); triggerText.textContent = option.textContent; valueInput.value = option.dataset.value; wrapper.querySelectorAll('.custom-option.selected').forEach(sel => sel.classList.remove('selected')); option.classList.add('selected'); const manualEntryDiv = container.querySelector('.credential-manual-entry'); const usernameInput = manualEntryDiv.querySelector('.credential-username-input'); const passwordInput = manualEntryDiv.querySelector('.credential-password-input'); const isManual = option.dataset.value === 'manual'; manualEntryDiv.style.display = isManual ? 'block' : 'none'; usernameInput.required = isManual; passwordInput.required = isManual; closeAllCustomSelects(); } }
function handleCredentialFilter(event) { const input = event.target; if (!input.classList.contains('credential-filter-input')) return; const optionsContainer = input.closest('.custom-options'); if (!optionsContainer) return; const filterText = input.value.toLowerCase(); optionsContainer.querySelectorAll('.custom-option:not(.filter-option)').forEach(option => { const optionText = option.textContent.toLowerCase(); option.style.display = optionText.includes(filterText) ? 'block' : 'none'; }); }
function getAuthPayload(idPrefix) { if (!masterKey) { throw new Error("Master Key is not set. Please set it in 'Credential Management'."); } const container = document.querySelector(`.credential-selector-container[data-id-prefix="${idPrefix}"]`); if (!container) { throw new Error(`Could not find selector container for prefix '${idPrefix}'.`); } const valueInput = container.querySelector('.credential-selector-value'); const selectedValue = valueInput.value; if (selectedValue === 'manual') { const username = container.querySelector('.credential-username-input').value; const password = container.querySelector('.credential-password-input').value; if (!username || !password) { throw new Error('For manual entry, API Key and Secret are required.'); } return { username, password }; } else if (selectedValue) { return { account_name: selectedValue, master_key: masterKey }; } else { throw new Error('Please select a credential or choose "Manual Entry".'); } }
function openOuterTab(evt, tabName) { let i, tabcontent, tablinks; tabcontent = document.getElementsByClassName("tab-content"); for (i = 0; i < tabcontent.length; i++) { tabcontent[i].style.display = "none"; } tablinks = document.getElementsByClassName("tab-link"); for (i = 0; i < tablinks.length; i++) { tablinks[i].className = tablinks[i].className.replace(" active", ""); } const targetTab = document.getElementById(tabName); if (targetTab) { targetTab.style.display = "block"; } else { console.error("Target outer tab not found:", tabName); if (tabcontent.length > 0) tabcontent[0].style.display = "block"; if (tablinks.length > 0) tablinks[0].className += " active"; return; } evt.currentTarget.className += " active"; clearResponse(); closeAllAccordions(targetTab); }
function openInnerTab(evt, tabName, clickedElement) { const parentActionContent = clickedElement.closest('.action-content'); if (!parentActionContent) return; let i, tabcontent, tablinks; tabcontent = parentActionContent.getElementsByClassName("inner-tab-content"); for (i = 0; i < tabcontent.length; i++) { tabcontent[i].style.display = "none"; } tablinks = parentActionContent.getElementsByClassName("inner-tab-link"); for (i = 0; i < tablinks.length; i++) { tablinks[i].className = tablinks[i].className.replace(" active", ""); } const targetTab = parentActionContent.querySelector(`#${tabName}`); if (targetTab) { targetTab.style.display = "block"; clickedElement.className += " active"; clearResponse(); } else { console.error("Target inner tab content not found:", tabName); } }
function closeAllAccordions(parentElement) { parentElement.querySelectorAll('.accordion > details').forEach(details => { details.removeAttribute('open'); }); }
function setupAccordionBehavior() { const accordions = document.querySelectorAll('.accordion'); accordions.forEach(accordion => { const mainDetailsElements = accordion.querySelectorAll(':scope > details'); mainDetailsElements.forEach(details => { details.addEventListener('toggle', (event) => { if (details.open && event.target === details) { mainDetailsElements.forEach(sibling => { if (sibling !== details && sibling.open) { sibling.removeAttribute('open'); } }); if (details.querySelector('.inner-tabs')) { const firstInnerTabLink = details.querySelector('.inner-tab-link'); const firstInnerTabContentId = firstInnerTabLink?.getAttribute('onclick').match(/'([^']+)'/)[1]; const firstInnerTabContent = details.querySelector(`#${firstInnerTabContentId}`); if (firstInnerTabLink && firstInnerTabContent && !firstInnerTabLink.classList.contains('active')) { openInnerTab({ currentTarget: firstInnerTabLink }, firstInnerTabContent.id, firstInnerTabLink); } } else if (details.id === 'vonageModifyDidAccordion') { populateModifyDidUriDatalist(); } } }); }); }); }
function renderStoredItems(type, containerId, noItemsMsgId, itemsArray) { const container = document.getElementById(containerId); const noItemsMsg = document.getElementById(noItemsMsgId); if (!container || !noItemsMsg) return; container.innerHTML = ''; if (!itemsArray || itemsArray.length === 0) { noItemsMsg.textContent = `No stored ${type}s loaded or found.`; noItemsMsg.style.display = 'block'; return; } noItemsMsg.style.display = 'none'; itemsArray.forEach((item, index) => { const itemRow = document.createElement('div'); itemRow.className = 'stored-item-row'; const itemLabel = document.createElement('div'); itemLabel.className = 'stored-item-label'; itemLabel.textContent = item.label || `Unlabeled ${type.toUpperCase()}`; const itemValue = document.createElement('div'); itemValue.className = 'stored-item-value'; itemValue.textContent = item[type]; const deleteButton = document.createElement('button'); deleteButton.textContent = 'âœ•'; deleteButton.className = 'stored-item-delete-btn'; deleteButton.title = `Remove ${type.toUpperCase()} from session`; deleteButton.type = 'button'; deleteButton.dataset.index = index; deleteButton.dataset.type = type; deleteButton.addEventListener('click', handleDeleteStoredItem); itemRow.appendChild(itemLabel); itemRow.appendChild(itemValue); itemRow.appendChild(deleteButton); container.appendChild(itemRow); }); }
function renderVonageStoredIps() { renderStoredItems('ip', 'vonage_psip_storedItemsContainer', 'vonage_psip_noStoredItems', vonageStoredIps); }
function renderVonageStoredUris() { renderStoredItems('uri', 'vonage_config_storedItemsContainer', 'vonage_config_noStoredItems', vonageStoredUris); populateUriDatalist('stored-uris-list'); populateModifyDidUriDatalist(); }
function populateUriDatalist(datalistId) { const datalist = document.getElementById(datalistId); if (!datalist) return; datalist.innerHTML = ''; vonageStoredUris.forEach(item => { const option = document.createElement('option'); option.value = item.uri; option.label = item.label ? `${item.label} (${item.uri})` : item.uri; datalist.appendChild(option); }); }
function populateModifyDidUriDatalist() { populateUriDatalist('vonageModify_storedUrisDatalist'); }
function handleAddStoredItem(event) { const type = event.target.dataset.type; const parentContainer = event.target.closest('.action-content, div[style*="padding: 10px"]'); if (!parentContainer) return; const valueInput = parentContainer.querySelector(`#vonage_${type === 'ip' ? 'psip' : 'config'}_newItemValue`); const labelInput = parentContainer.querySelector(`#vonage_${type === 'ip' ? 'psip' : 'config'}_newItemLabel`); let value = valueInput?.value.trim(); const label = labelInput?.value.trim(); if (!value) { alert(`Please enter a value for the ${type.toUpperCase()}.`); return; } if (type === 'ip') { const ipv4Pattern = /^(\d{1,3}\.){3}\d{1,3}(\/\d{1,2})?$/; if (!ipv4Pattern.test(value)) { alert('Please enter a valid IPv4 address (e.g. 192.168.1.1 or 192.168.1.1/32)'); return; } if (!value.includes('/')) { value += '/32'; } vonageStoredIps.push({ ip: value, label }); renderVonageStoredIps(); } else if (type === 'uri') { vonageStoredUris.push({ uri: value, label }); renderVonageStoredUris(); } if (valueInput) valueInput.value = ''; if (labelInput) labelInput.value = ''; }
function handleDeleteStoredItem(event) { const index = parseInt(event.target.dataset.index, 10); const type = event.target.dataset.type; if (isNaN(index)) return; if (type === 'ip') { vonageStoredIps.splice(index, 1); renderVonageStoredIps(); } else if (type === 'uri') { vonageStoredUris.splice(index, 1); renderVonageStoredUris(); } }

// --- Status & Response Display Functions ---
function displayOperationStatusMessage(message, parentArea, referenceNode) { parentArea.querySelectorAll('p.status-message').forEach(p => p.remove()); const p = document.createElement('p'); p.textContent = message; p.className = 'status-message'; parentArea.insertBefore(p, referenceNode); }
function addOrUpdateOperationStatus(id, text, statusClass, listEl) { if (!listEl) return; let li = listEl.querySelector(`li[data-status-id="${id}"]`); let prefix = String(id).startsWith('NPA-FIND-') ? `NPA ${String(id).substring(9)} (Find): ` : `${id}: `; if (!li) { li = document.createElement('li'); li.dataset.statusId = id; const idSpan = document.createElement('span'); idSpan.textContent = prefix; idSpan.style.fontWeight = 'bold'; const statusSpan = document.createElement('span'); li.appendChild(idSpan); li.appendChild(statusSpan); listEl.appendChild(li); } const statusSpan = li.querySelector('span:last-child'); if (statusSpan) { statusSpan.textContent = text; statusSpan.className = `status-${statusClass}`; } }
function displayResponse(message, type = '', isHtml = false) { const area = document.getElementById('response'); if (!area) return; area.style.display = 'block'; area.className = type; if (isHtml) { area.innerHTML = message; } else { area.textContent = message; } area.scrollIntoView({ behavior: 'smooth', block: 'end' }); }
function clearResponse() { const area = document.getElementById('response'); if (area) { area.style.display = 'none'; area.textContent = ''; area.innerHTML = ''; area.className = ''; } }
function handleBackendResponse(data) { if (data.error) { let msg = `Error: ${data.error}\n`; if(data.status_code) msg += `Status Code: ${data.status_code}\n`; if(data.response_data_json && Object.keys(data.response_data_json).length > 0) { msg += "API Error (JSON):\n" + JSON.stringify(data.response_data_json, null, 2); } else if (data.response_data_text) { msg += "API Error (Text):\n" + data.response_data_text; } else if (data.data && typeof data.data === 'object' && data.data.error) { msg += "Details: " + data.data.error; } else if (data.data && typeof data.data === 'string') { msg += "Details: " + data.data; } displayResponse(msg, 'error'); } else { let msg = `Success! Status: ${data.status_code || 'N/A'}\n\n`; if (data.message) { msg = `${data.message}\nStatus Code: ${data.status_code || 'N/A'}\n\n`; } if (data.data && Object.keys(data.data).length > 0 && JSON.stringify(data.data) !== '{}') { msg += "Response:\n" + JSON.stringify(data.data, null, 2); } displayResponse(msg, 'success'); } }
function handleFetchError(error, operation = 'request') { console.error(`Error during ${operation}:`, error); displayResponse(`Error: Could not connect to the backend or network issue during ${operation}.\n\n${error.message}`, 'error'); }

// --- Initialization ---
function loadInitialData() {
    apiFetch('/api/ips').then(res=>res.json()).then(data=>{vonageStoredIps=data;renderVonageStoredIps();}).catch(e=>console.error('Error fetching IPs:',e));
    apiFetch('/api/uris').then(res=>res.json()).then(data=>{vonageStoredUris=data;renderVonageStoredUris();}).catch(e=>console.error('Error fetching URIs:',e));
    apiFetch('/api/npa-data').then(res=>res.json()).then(data=>{npaData=data;console.log("NPA data loaded.");}).catch(e=>{console.error('CRITICAL: Could not load NPA data.',e);displayResponse("Error: Could not load NPA data. Auto-detection will fail.","error");});
    apiFetch('/api/settings').then(res => res.json()).then(data => { if (data && typeof data === 'object') { appSettings = { ...appSettings, ...data }; console.log("Application settings loaded from database.", appSettings); } }).catch(e => console.error('Error fetching application settings:', e));
}

// --- DOMContentLoaded Event Listener ---
document.addEventListener('DOMContentLoaded', () => {
    // Initial Setup
    loadInitialData();
    setupAccordionBehavior();
    const selectorTemplate = document.getElementById('credential-selector-template');
    if(selectorTemplate){document.querySelectorAll('.credential-selector-container').forEach(c=>{const p=c.dataset.idPrefix,cl=selectorTemplate.content.cloneNode(true);cl.querySelector('.credential-selector-label').htmlFor=`${p}_selector_value`;cl.querySelector('.credential-selector-value').id=`${p}_selector_value`;cl.querySelector('.credential-username-label').htmlFor=`${p}_username`;cl.querySelector('.credential-username-input').id=`${p}_username`;cl.querySelector('.credential-password-label').htmlFor=`${p}_password`;cl.querySelector('.credential-password-input').id=`${p}_password`;c.appendChild(cl);});}
    
    document.addEventListener('click', handleCustomSelectClick);
    document.body.addEventListener('keyup', handleCredentialFilter);

    const firstTab = document.querySelector('.tab-link'); if(firstTab) firstTab.click();
    
    // Credential Listeners
    document.getElementById('setMasterKeyButton')?.addEventListener('click', handleSetMasterKey);
    document.getElementById('addCredentialForm')?.addEventListener('submit', handleAddCredential);
    document.getElementById('credentialListContainer')?.addEventListener('click', handleCredentialListActions);
    document.getElementById('importCredentialsButton')?.addEventListener('click', handleBulkImportCredentials);
    document.getElementById('importFromFileButton')?.addEventListener('click', handleImportFromFile);
    document.getElementById('rekeyCredentialsButton')?.addEventListener('click', handleRekeyCredentials);
    
    // Settings & Log Listeners
    const settingsModal = document.getElementById('settingsModal');
    document.getElementById('settingsGearIcon')?.addEventListener('click', async () => { try { const response = await apiFetch('/api/settings'); const latestSettings = await response.json(); if (response.ok) { appSettings = { ...appSettings, ...latestSettings }; } else { throw new Error(latestSettings.error || "Failed to fetch settings"); } } catch (error) { console.error("Could not fetch latest settings:", error); displayResponse(`Error: Could not load settings from database. Displaying last known values.`, 'error'); } document.getElementById('maxConcurrentRequests').value = appSettings.max_concurrent_requests; document.getElementById('delayBetweenBatches').value = appSettings.delay_between_batches_ms; document.getElementById('storeLogsToggle').checked = appSettings.store_logs_enabled; document.getElementById('treat420AsSuccess_buy').checked = appSettings.treat_420_as_success_buy; document.getElementById('verifyOn420_buy').checked = appSettings.verify_on_420_buy; document.getElementById('treat420AsSuccess_configure').checked = appSettings.treat_420_as_success_configure; settingsModal.style.display = 'block'; });
    document.getElementById('settingsModalClose')?.addEventListener('click', () => { settingsModal.style.display = 'none' });
    document.getElementById('cancelSettingsButton')?.addEventListener('click', () => { settingsModal.style.display = 'none' });
    document.getElementById('saveSettingsButton')?.addEventListener('click', async () => { const newSettings = { max_concurrent_requests: parseInt(document.getElementById('maxConcurrentRequests').value, 10), delay_between_batches_ms: parseInt(document.getElementById('delayBetweenBatches').value, 10), store_logs_enabled: document.getElementById('storeLogsToggle').checked, treat_420_as_success_buy: document.getElementById('treat420AsSuccess_buy').checked, verify_on_420_buy: document.getElementById('verifyOn420_buy').checked, treat_420_as_success_configure: document.getElementById('treat420AsSuccess_configure').checked, }; try { const response = await apiFetch('/api/settings', { method: 'POST', body: JSON.stringify(newSettings) }); const data = await response.json(); if (!response.ok) throw new Error(data.error || "Failed to save"); appSettings = { ...appSettings, ...newSettings }; settingsModal.style.display = 'none'; displayResponse('Settings saved to database!', 'success'); } catch (error) { console.error("Failed to save settings:", error); displayResponse(`Error saving settings: ${error.message}`, 'error'); } });
    document.getElementById('treat420AsSuccess_buy')?.addEventListener('change',e=>{if(e.target.checked)document.getElementById('verifyOn420_buy').checked=false;});document.getElementById('verifyOn420_buy')?.addEventListener('change',e=>{if(e.target.checked)document.getElementById('treat420AsSuccess_buy').checked=false;});
    document.getElementById('downloadLogsButton')?.addEventListener('click',()=>{window.location.href='/api/logs/download';});document.getElementById('clearLogsButton')?.addEventListener('click',()=>{if(confirm('Delete all server logs?')){apiFetch('/api/logs/clear',{method:'POST'}).then(r=>r.json()).then(d=>{if(d.error)displayResponse(`Error: ${d.error}`,'error');else displayResponse('Logs cleared.','success');}).catch(e=>displayResponse(`Failed: ${e.message}`,'error'));}});
    const countryModal=document.getElementById('countryCodesModal');document.querySelectorAll('.showCountryCodesBtn').forEach(btn => btn.addEventListener('click', () => { countryModal.style.display='block'; }));document.getElementById('countryCodesModalClose')?.addEventListener('click',()=>{countryModal.style.display='none';});window.addEventListener('click',e=>{if(e.target===settingsModal)settingsModal.style.display='none';if(e.target===countryModal)countryModal.style.display='none';});
    const ccl=document.getElementById('countryCodesList');if(ccl)ccl.innerHTML=`<ul style="list-style-type:none;padding:0;">${countryData.sort((a,b)=>a.name.localeCompare(b.name)).map(c=>`<li data-country-name="${c.name.toLowerCase()}" style="padding:5px;border-bottom:1px solid #eee;">${c.name} (<strong>${c.code}</strong>) - +${c.dial}</li>`).join('')}</ul>`;
    document.getElementById('countryCodeSearch')?.addEventListener('keyup',e=>{const f=e.target.value.toLowerCase(),i=document.getElementById('countryCodesList').getElementsByTagName('li');for(let j=0;j<i.length;j++)i[j].style.display=i[j].textContent.toLowerCase().includes(f)?"":"none";});
    
    // Vonage Listeners
    document.getElementById('vonageFetchSubaccountsForm')?.addEventListener('submit',handleFetchSubaccounts);document.getElementById('vonageCreateSubaccountForm')?.addEventListener('submit',handleCreateSubaccount);document.getElementById('vonage-subaccount-list')?.addEventListener('click',handleSubaccountActions);document.getElementById('vonage_new_subaccount_use_primary_balance')?.addEventListener('change',function(){document.getElementById('vonage_new_subaccount_use_primary_balance_status').textContent=this.checked?'On':'Off';});
    document.getElementById('vonagePsipForm')?.addEventListener('submit',handleVonagePsipSubmit);document.getElementById('vonage_psip_digest_auth')?.addEventListener('change',function(){document.getElementById('vonage_psip_digest_auth_status').textContent=this.checked?'On':'Off';});document.getElementById('vonage_psip_include_stored_ips')?.addEventListener('change',function(){vonageIncludeStoredIps=this.checked;});document.querySelectorAll('.add-stored-item-btn').forEach(b=>b.addEventListener('click',handleAddStoredItem));document.getElementById('vonage_psip_previewButton')?.addEventListener('click',()=>displayResponse('JSON Payload Preview:\n\n'+JSON.stringify(generateVonagePsipPayload(),null,2)));document.getElementById('vonage_psip_copyButton')?.addEventListener('click',()=>{const c=generateVonagePsipCurlCommand();navigator.clipboard.writeText(c).then(()=>displayResponse('cURL copied!\n\n'+c,'success'),()=>displayResponse('Copy failed:\n\n'+c));});document.getElementById('vonageFetchPsipDomainsForm')?.addEventListener('submit',handleFetchPsipDomains);document.getElementById('vonage-psip-domain-list')?.addEventListener('click',handlePsipDomainActions);
    document.getElementById('vonageSearchForm')?.addEventListener('submit',handleVonageSearchSubmit);document.getElementById('vonage_purchase_button')?.addEventListener('click',handlePurchaseButtonClick);document.getElementById('vonage_bulk_npa_purchase_button')?.addEventListener('click',handleBulkNpaPurchaseClick);document.getElementById('vonage_configure_button')?.addEventListener('click',handleConfigureClick);document.getElementById('vonage_export_button')?.addEventListener('click',handleExportClick);document.getElementById('search-results-container')?.addEventListener('change',e=>{if(e.target.classList.contains('did-checkbox'))updateSelectedCount();});
    const mdf=document.getElementById('vonageModifyDidForm');if(mdf){mdf.addEventListener('submit',handleVonageModifyDidSubmit);document.getElementById('vonageModify_mode_toggle')?.addEventListener('change',function(){const c=this.checked;document.getElementById('vonageModify_mode_status').textContent=c?'CSV Upload':'Manual Entry';document.getElementById('vonageModify_csv_section').style.display=c?'block':'none';document.getElementById('vonageModify_manual_section').style.display=c?'none':'block';});document.getElementById('vonageModify_country_mode_toggle')?.addEventListener('change',function(){const m=this.checked;document.getElementById('vonageModify_country_other_container').style.display=m?'block':'none';document.querySelector('#vonageModifyDidForm .country-mode-status').textContent=m?'Other (Manual)':'US/CA (Auto-Detect)';});mdf.querySelectorAll('.toggle input[data-config-param]').forEach(cb=>{const t=document.getElementById(cb.dataset.inputTarget);if(t){cb.addEventListener('change',()=>{t.disabled=!cb.checked;if(t.id.includes('voiceCallback'))document.getElementById('vonageModify_voiceCallbackType').dispatchEvent(new Event('change'));});t.disabled=!cb.checked;}});const mvt=document.getElementById('vonageModify_voiceCallbackType'),msf=document.getElementById('vonage_modify_sip_failover_container'),mc=()=>{const t=document.getElementById('vonageModify_voiceCallbackType_toggle')?.checked,v=document.getElementById('vonageModify_voiceCallbackValue_toggle').checked,s=mvt.value==='sip';document.getElementById('vonageModify_voiceCallbackValue').disabled=!t||!v;msf.style.display=(t&&s)?'flex':'none';document.getElementById('vonageModify_voiceCallbackValue').setAttribute('list',s?'vonageModify_storedUrisDatalist':'');};mvt?.addEventListener('change',mc);document.getElementById('vonageModify_voiceCallbackType_toggle')?.addEventListener('change',mc);document.getElementById('vonageModify_voiceCallbackValue_toggle')?.addEventListener('change',mc);mc();}
    const cvt=document.getElementById('vonage_config_voiceCallbackType');if(cvt){const tcf=function(){const s=this.value==='sip';document.getElementById('vonage_config_voiceCallbackValue').setAttribute('list',s?'stored-uris-list':'');document.getElementById('vonage_config_sip_failover_container').style.display=s?'block':'none';};cvt.addEventListener('change',tcf);tcf.call(cvt);}
    document.getElementById('vonageReleaseDidForm')?.addEventListener('submit', handleVonageReleaseDidSubmit);
    document.getElementById('vonageRelease_country_mode_toggle')?.addEventListener('change', function() { const isManual = this.checked; document.getElementById('vonageRelease_country_other_container').style.display = isManual ? 'block' : 'none'; document.querySelector('#vonageReleaseDidForm .country-mode-status').textContent = isManual ? 'Other (Manual)' : 'US/CA (Auto-Detect)'; });
    document.querySelectorAll('.stop-button').forEach(btn => btn.addEventListener('click', stopAllOperations));
});
// --- END OF FILE static/js/script.js ---